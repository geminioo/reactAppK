/**
 * Sherlockholmes
 * -------------
 * redux logger proxy
 */

'use strict'

// Optional. You will see this name in eg. 'ps' or 'top' command
process.title = 'sherlockholmes'

// websocket and http servers
import { server as webSocketServer } from 'websocket'
import http from 'http'
import chalk from 'chalk'
import boxen from 'boxen'
import express from 'express'
import opn from 'opn'
import { config } from '../config'

/**
 * Global variables
 */
const WebSocketServer = webSocketServer
// Port where we'll run the websocket server
const webSocketsServerPort = config.WS_PORT

/**
 * HTTP server
 */
const app = express()
app.use(express.static(__dirname + '/../public'))

const server = http.createServer(app)

server.listen(webSocketsServerPort, () => {
  opn(`http://localhost:${webSocketsServerPort}`)
  const msg = chalk.green(`Sherlockholmes start detecting on port : ${webSocketsServerPort}`)
  console.log(boxen(msg, { padding: 1 }))
})

/**
 * WebSocket server
 */
const wsServer = new WebSocketServer({
  // WebSocket server is tied to a HTTP server. WebSocket
  // request is just an enhanced HTTP request. For more info
  // http://tools.ietf.org/html/rfc6455#page-6
  httpServer: server,

  // 16MiB max frame size.
  maxReceivedFrameSize: 0x1000000,

  // 16MiB max message size, only applicable if
  // assembleFragments is true
  maxReceivedMessageSize: 0x1000000,
})

const message = (message) => {
  console.log(chalk.blue(`${new Date().toLocaleString()} - ${message}`))
}

// This callback function is called every time someone
// tries to connect to the WebSocket server
wsServer.on('request', (request) => {
  message(`Connection from origin: ${request.origin}`)

  // accept connection - you should check 'request.origin' to
  // make sure that client is connecting from your website
  // (http://en.wikipedia.org/wiki/Same_origin_policy)
  const connection = request.accept(null, request.origin)

  message('Connection accepted.')

  // user sent some message
  connection.on('message', (message) => {

    // accept only text
    if (message.type === 'utf8') {
      // transform data
      const json = JSON.stringify({ type: 'message', data: message })

      // broadcast data to clients
      wsServer.broadcast(json)
    }
  })
  // user disconnected
  connection.on('close', (connection, closeReason, description) => {
    message(`Exit with reason: ${closeReason}`)
  })
})
