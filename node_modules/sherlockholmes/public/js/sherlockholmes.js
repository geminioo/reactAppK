$(function sherlockholmes() {
  'use strict'

  const root         = $('#sherlockholmes')
  const $status      = $('.sherlockholmes-status__title')
  const $actions     = $('.actions')
  const $prevState   = $('#prev-state')
  const $nextState   = $('#next-state')
  const $themeSelect = $('.theme-select')
  const data         = []
  const treeOpts     = { source: [], icon: false }

  let connection   = null
  let localStorage = null

  $prevState.fancytree(treeOpts)
  $nextState.fancytree(treeOpts)

  // if user is running mozilla then use it's built-in WebSocket
  window.WebSocket = window.WebSocket || window.MozWebSocket

  // if browser doesn't support WebSocket, just show
  // some notification and exit
  if (!window.WebSocket) {
    $status
      .removeClass('status-success')
      .removeClass('status-error')
      .addClass('status-error')
      .text('Sorry, but your browser doesn\'t support WebSocket.')
    return
  }

  if (!window.localStorage) {
    alert('Sorry, but you browser doesn\'t support LocalStorage. \nTheme will be change to the default when refresh page')
  } else {
    localStorage = window.localStorage
  }

  /**
   * Theme
   * @type {{set: (function(*=)), get: (function())}}
   */
  const theme = {
    set(theme) {
      if (localStorage) {
        localStorage.setItem('sherlockholmes-theme', theme)
      }
    },
    get() {
      if (localStorage) {
        let theme = localStorage.getItem('sherlockholmes-theme')
        return theme? theme : 'light'
      } else {
        return 'light'
      }
    }
  }

  let oldTheme = theme.get()
  $themeSelect.change(() => {
    let themeSelected = $(this).find('option:selected').val()
    switch (themeSelected) {
      case 'light':
        root.removeClass(oldTheme)
        oldTheme = themeSelected
        theme.set(themeSelected)
        break
      default:
        root.removeClass(oldTheme).addClass(themeSelected)
        oldTheme = themeSelected
        theme.set(themeSelected)
    }
  })
  $themeSelect.val(oldTheme).change()

  /**
   * Expand tree
   * -----
   * @param tree
   * @param level
   */
  const expandTreeLevel = (tree, level = 3) => {
    let cnt = 0
    tree.visit((node) => {
      if (cnt < level) {
        node.setExpanded(true)
        cnt++
      }
    })
  }

  /**
   * Reload tree node
   * -----
   * @param treeElement
   * @param data
   */
  const reloadTree = (treeElement, data) => {
    const tree = treeElement.fancytree('getTree')
    tree.reload(data)
    expandTreeLevel(tree)
  }

  /**
   * Temporary data
   * -----
   * @param state
   */
  const saveData = (state) => {
    data.push(state)
  }

  /**
   * Transform state
   * -----
   * @param state
   * @returns {Array}
   */
  const transformState = (state) => {
    return Object.keys(state).map((key) => {
      return {
        key     : Date.now(),
        title   : `${key} ${Array.isArray(state[key])
                            ? ' [] = ' + state[key].length
                            : typeof state[key] !== 'object'
                              ? ' <small class="'+ typeof state[key] +'">('+ typeof state[key] +') = ' + state[key] + '</small>'
                              : '' }`,
        children: Array.isArray(state[key]) && typeof state[key][0] === 'string'
                    ? state[key]
                    : typeof state[key] === 'object' && state[key]
                      ? transformState(state[key])
                      : null
      }
    })
  }

  /**
   * Show active action
   * -----
   * @param id
   */
  let oldActive = null
  const showActiveAction = (id) => {

    if (oldActive) {
      $(`#${oldActive}`).removeClass('active')
    }

    $(`#${id}`).addClass('active')
    oldActive = id
  }

  /**
   * On click action
   * -----
   * Re-render store when click on action
   * @param id
   */
  const onClickAction = (id) => {
    const idx = data.findIndex((d) => d.id === id)
    renderStore(data[idx])
    showActiveAction(id)
  }

  /**
   * Render action
   * -----
   * @param data
   */
  const renderAction = (data) => {
    const li       = $('<li>', { 'id': data.id, 'data-id': data.id })
    const a        = $('<a>', { 'href': 'javascript:void(0)' })
    const action   = $('<strong>', { 'text': data.type })
    const datetime = $('<small>', { 'text': new Date(data.date).toLocaleTimeString() })
    a.bind('click', () => onClickAction(data.id) )
    a.append(action)
    a.append(datetime)
    li.html(a)
    $actions.prepend(li)
    showActiveAction(data.id)
  }

  /**
   * Render store
   * -----
   * @param data
   */
  const renderStore = (data) => {
    ['prev', 'next'].map((state) => {
      switch (state) {
        case 'prev' :
          reloadTree($prevState, transformState(data[state]))
          break
        case 'next' :
          reloadTree($nextState, transformState(data[state]))
          break
        default: console.log('State should be next or prev')
      }
    })
  }

  /**
   * Connect to websocket
   */
  const connect = () => {
    try {
      connection = new WebSocket('ws://127.0.0.1:9986')
    } catch (e) {
      $status
        .removeClass('status-info')
        .removeClass('status-success')
        .removeClass('status-error')
        .addClass('status-error')
        .text(e.message)
    }
    connection.onopen = () => {
      $status
        .removeClass('status-info')
        .removeClass('status-error')
        .removeClass('status-success')
        .addClass('status-success')
        .text('Starting detect...')
    }
    connection.onclose = (error) => {
      $status
      .removeClass('status-error')
      .removeClass('status-success')
      .removeClass('status-info')
      .addClass('status-info')
      .text('Re-connecting...')
    }
    connection.onerror = (error) => {
      // just in there were some problems with connection...
      $status
        .removeClass('status-info')
        .removeClass('status-success')
        .removeClass('status-error')
        .addClass('status-error')
        .text('Sorry, but there\'s some problem with your connection or the server is down.')
    }
    // most important part - incoming messages
    connection.onmessage = (message) => {
      // try to parse JSON message. Because we know that the server
      // always returns JSON this should work without any problem but
      // we should make sure that the massage is not chunked or
      // otherwise damaged.
      let json = null

      try {
        json = JSON.parse(message.data)
      } catch (e) {
        console.log('Invalid JSON: ', message.data)
        return
      }

      const jsonData  = JSON.parse(json.data.utf8Data);
      const transform = {
        id  : Date.now(),
        type: jsonData.action.type,
        prev: jsonData.prev,
        next: jsonData.next,
        date: Date.now()
      }
      saveData(transform)
      renderAction(transform)
      renderStore(transform)
    }
  }

  // connect websocket
  connect()

  /**
   * This method is optional. If the server wasn't able to
   * respond to the in 3 seconds then show some error message
   * to notify the user that something is wrong.
   */
  setInterval(function() {
    if (connection.readyState !== connection.OPEN) {
      $status
        .removeClass('status-info')
        .removeClass('status-success')
        .removeClass('status-error')
        .addClass('status-error')
        .text('Unable to communicate with the WebSocket server.')

      // if lost the connection retry to connect.
      setTimeout(connect, 1000)
    }
  }, 10000)
})
